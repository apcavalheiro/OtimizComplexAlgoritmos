**Resumo capítulo 2 continuação**

Este resumo discute a eficiência do tempo de execução de um algoritmo, concentrando-se em vários exemplos. O primeiro exemplo é o algoritmo para selecionar o elemento menos não classificado e colocá-lo no final da parte ordinal do array. O segundo exemplo é o algoritmo de inserção de elementos no array, que é um algoritmo quadrático. Esta análise é crucial porque garante que o limite de tempo obtido pelo algoritmo Big Oh esteja sempre correto. No entanto, pode ser muito geral, o que significa que o tempo real do pior caso pode ser inferior ao obtido através desta análise.
O terceiro exemplo é a correspondência de padrões de cordas. Esta é a operação algébrica mais fundamental em cadeias de texto. Este algoritmo implementa o comando find disponível em qualquer navegador web ou editor de texto. O problema é a correspondência dos padrões de substring. Este é um algoritmo simples que considera a possibilidade de começar em cada posição possível e testa se for o caso.
O quarto exemplo é a comparação dos comprimentos dos elementos de uma lista. Este é um algoritmo simples que verifica se todas as três dimensões são iguais. Se for comum o caso em que todas as três dimensões são iguais, torna-se um algoritmo cúbico.
Concluindo, este resumo fornece uma visão abrangente da eficiência de vários algoritmos, incluindo a seleção de elementos, a correspondência de padrões de strings e a comparação de comprimentos.
Logaritmos são funções exponenciais inversas que crescem gradativamente lentamente, como uma das funções exponenciais em qualquer processo em que as coisas são repetidamente decrescentes à metade. A busca binária é uma das ideias mais poderosas no design de algoritmos, pois são rápidas ou suficientes para serem usadas em instâncias de problemas de tamanho essencialmente ilimitado.
Árvores binárias de altura 1 podem ter até 2 nós de folha, enquanto uma árvore de altura 2 pode ter até quatro folhas. O número de folhas possíveis é multiplicado por cada vez que aumentamos a altura em um, então é a principal razão pela qual as árvores muito curtas podem ter muitas folhas, o que é a principal razão pela que as árvores binárias são fundamentais para o projeto de estruturas de dados rápidos.
Os logaritmos eram particularmente importantes nos dias anteriores às calculadoras de bolso, fornecendo a maneira mais fácil de multiplicar números grandes à mão. Os logaritmos são úteis para multiplicação, particularmente para exponenciação. O logaritmo de um produto é a soma dos logs, e a consequência direta é que o problema é reduzido a uma multiplicação mais uma chamada para cada uma dessas funções.
O algoritmo mais simples executa multiplicações, calculando. Em ambos os casos, reduzimos pela metade o tamanho do nosso expoente ao custo de, no máximo, duas multiplicações, então multiplicações são suficientes para calcular o valor final.
O algoritmo simples ilustra um princípio importante de dividir e conquistar, que seja aplicável à vida real. Quando não é uma potência de dois, o problema não pode ser dividido uniformemente, mas a diferença de um elemento entre os dois lados não pode causar nenhum desequilíbrio sério.
Logaritmos é uma técnica de logaritmo que utiliza um número de números e somas para entender a progressão aritmética. Os números harmônicos surgem como um caso especial de progressão aritmética, relacionando-se à soma da progressão de recíprocos simples. Eles são importantes porque explicam o "de onde vem o tronco" quando um magicamente sai da manipulação algébrica.
As Diretrizes Federais de Sentença para Fraude têm uma função de ponto real para fraude, mapeando dólares roubados em pontos. A segurança aumenta em um nível cada vez que a quantidade de dinheiro descoberto praticamente dobra. O nível de resiliência cresce logaritmicamente com a quantidade de dinheiro roubado.
Os logaritmos surgem sempre que as coisas são repetidamente reduzidas à metade ou duplicadas. O termo b é conhecido como a base do logaritmo, com base b=2 – O logaritmo binário, base b=e – O logaritmo natural, base b=10 – Menores hoje é a b-10 ou logaritmo comum, base b= 10 – O base b=b=b=c.
A propriedade importante dos logaritmos é que é fácil converter um logaritmo de uma base para outra. Uma grande mudança na base do logaritmo produz pouca diferença no valor do logaritmo, em consequência, geralmente temos justificativa para ignorar a base do logaritmo ao analisar algoritmos.
Os logaritmos resultantes de qualquer função ao tamanho, e a taxa de crescimento do logaritmo de qualquer função polinomial é O (lg n). Uma pesquisa binária em uma matriz ordenada de n^2 requer apenas duas vezes mais comparações do que uma pesquisa binária em n coisas. O poder da busca binária em uma ampla gama de problemas é uma consequência dessa observação.
A importância de uma divisão uniforme é importante para a quantidade de consultas ao pesquisa binária em uma lista telefônica realizada em Manhattan. Para a lista telefônica de Manhattan, agora usamos 〖log〗_(3/2) (1.000.000) ≈ 35 consultas no pior caso, não uma mudança significativa de 〖log〗_2 (1.000.000) ≈ 20. O poder da A busca binária vem de sua complexidade logarítmica, não a base do log.
Aquele olhar em seus olhos deveria ter me avisado antes de ele começar a falar. Os supercomputadores são rápidos e a força bruta parecia eliminar a necessidade de algoritmos inteligentes; pelo menos até os problemas ficarem difíceis.
Os primeiros números piramidais são 1,4,10,20,35,56,84,120 e 165. Uma conjectura desde 1928 é que todo número inteiro pode ser representado pela soma de no máximo cinco desses números piramidais. Um programa em supercomputadores funciona muito rápido em números menores, mas leva muito tempo assim que chega a 100.000 ou mais.
Os supercomputadores descobriram o crescimento assintótico, e o programa em que ele foi escrito tinha construído uma matriz de todos os Θ (n^ (1/3)) números piramidais de 1 e inclusive. Para testar cada número nesse intervalo, ele fez um teste de força bruta para estabelecer se era a soma de dois números piramidais.
Os logaritmos planejados com eficiência em avaliar a eficiência dos logaritmos em análise de algoritmos.
Um código de linha foi elaborado por uma criança que enfatizou o desempenho do programa, e o código foi executado em apenas 14 segundos, com um acréscimo de 5,3 vezes no período de quatro anos anteriores. O código foi elaborado com o compilador gcc, e a otimização de números piramidais é uma história primordial.
Ao escrever esta história de guerra, voltei a executar o programa mais de dez anos. No meu desktop SunBlade 150, o número resultante levava a 1.000.000 agora em 27,0 segundos, mas com otimização de nível 4, o trabalho foi executado em 14,0 segundos, tributo à qualidade do otimizador. O tempo de execução em minha máquina desktop melhorou por um fator de cerca de três no período de quatro anos anterior à minha primeira edição deste livro, com um acréscimo de 5,3 vezes nos últimos anos.
Um código foi modificado com a otimização de números piramidais, e um código foi modificado com a otimização de números piramidais.
Os códigos piramidais são da forma ((m³-m))/6, e o maior m tal que o número resultante seja no máximo n é ∛6n. Um código geral foi elaborado com a otimização de números piramidais, e um código foi elaborado com a otimização de números piramidais.
Os códigos piramidais são estruturados em dados classificados, e o código em dados classificados em dados classificados em dados classificados. Um código foi modificado com a otimização de números piramidais e a otimização de números piramidais, e um código foi modificado com a otimização de números piramidais e a otimização de números piramidais.

